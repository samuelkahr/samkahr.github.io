"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const ink_1 = require("ink");
const ink_link_1 = __importDefault(require("ink-link"));
const ink_spinner_1 = __importDefault(require("ink-spinner"));
const config_1 = require("../config");
const fs = __importStar(require("fs"));
const util_1 = require("util");
const api_1 = require("../api");
const gen_1 = require("../../generators/gen");
const templates_1 = require("../../templates");
const path_1 = require("path");
const childProcess = __importStar(require("child_process"));
const package_json_1 = require("../../../package.json");
const readFile = util_1.promisify(fs.readFile);
const readdir = util_1.promisify(fs.readdir);
const writeFile = util_1.promisify(fs.writeFile);
const unlink = util_1.promisify(fs.unlink);
const exec = util_1.promisify(childProcess.exec);
exports.Build = props => {
    const [generatorState, setGeneratorState] = react_1.useState(getInitialState(props.config));
    react_1.useEffect(() => {
        ;
        (() => __awaiter(this, void 0, void 0, function* () {
            var e_1, _a;
            // TODO: multiple tracking plans
            // TODO: replace this generator with split-up components, similar to Init.
            const progress = run(props.configPath, props.config, props.config.trackingPlans[0], {
                production: props.production,
                update: props.update,
            });
            try {
                for (var progress_1 = __asyncValues(progress), progress_1_1; progress_1_1 = yield progress_1.next(), !progress_1_1.done;) {
                    const step = progress_1_1.value;
                    // Note: we copy the state here s.t. React can identify that it needs to re-render.
                    setGeneratorState(Object.assign({}, step));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (progress_1_1 && !progress_1_1.done && (_a = progress_1.return)) yield _a.call(progress_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }))();
    }, []);
    return (react_1.default.createElement(ink_1.Box, { marginBottom: 1, marginTop: 1, flexDirection: "column" }, Object.entries(generatorState.steps).map(([k, step]) => {
        return react_1.default.createElement(Step, { key: k, step: step, stepName: k });
    })));
};
const Step = ({ stepName, step }) => {
    const stepDescriptions = {
        clearFiles: 'Removing generated files',
        loadPlan: 'Loading Tracking Plan',
        generateClient: 'Generating Typewriter client',
        afterScript: 'Cleaning up',
    };
    if (step.skipping) {
        return null;
    }
    return (react_1.default.createElement(ink_1.Box, { flexDirection: "column" },
        react_1.default.createElement(ink_1.Color, { white: true },
            react_1.default.createElement(ink_1.Box, { width: 3, justifyContent: "center" }, step.running ? react_1.default.createElement(ink_spinner_1.default, { type: "dots" }) : step.done ? react_1.default.createElement(ink_1.Color, { green: true }, " \u2714") : ''),
            react_1.default.createElement(ink_1.Box, { marginLeft: 1, width: 70 }, stepDescriptions[stepName])),
        step.notes.map(note => (react_1.default.createElement(ink_1.Color, { grey: !note.type || note.type === 'note', yellow: note.type === 'warning', key: note.key || String(note.text) },
            react_1.default.createElement(ink_1.Box, { marginLeft: 4 }, note.type === 'warning' ? '⚠' : '↪'),
            react_1.default.createElement(ink_1.Box, { marginLeft: 2, width: 70, textWrap: "wrap" }, note.text))))));
};
function getInitialState(config) {
    return {
        steps: {
            loadPlan: {
                running: false,
                done: false,
                skipping: false,
                notes: [],
            },
            clearFiles: {
                running: false,
                done: false,
                skipping: false,
                notes: [],
            },
            generateClient: {
                running: false,
                done: false,
                skipping: false,
                notes: [],
            },
            afterScript: {
                running: false,
                done: false,
                skipping: !config.scripts || !config.scripts.after,
                notes: [],
            },
        },
    };
}
function run(configPath, config, trackingPlanConfig, genOptions) {
    return __asyncGenerator(this, arguments, function* run_1() {
        const state = getInitialState(config);
        // Step 1: Load a Tracking Plan, either from the API or from the `plan.json` file.
        let step = state.steps.loadPlan;
        step.running = true;
        yield yield __await(state);
        const previousSegmentTrackingPlan = yield __await(api_1.loadTrackingPlan(configPath, trackingPlanConfig));
        if (genOptions.update) {
            step.notes.push({
                text: 'Pulling most recent version from Segment',
            });
            yield yield __await(state
            // TODO: support fine-grained event updates, by event name and by label.
            // For now, we will just support updating the full tracking plan.
            );
            // TODO: support fine-grained event updates, by event name and by label.
            // For now, we will just support updating the full tracking plan.
            const token = yield __await(config_1.getToken(config));
            if (!token) {
                step.notes.push({
                    type: 'warning',
                    key: 'empty-token',
                    text: (react_1.default.createElement(ink_1.Text, null,
                        "Unable to find a ",
                        '',
                        react_1.default.createElement(ink_link_1.default, { url: "https://segment.com/docs/protocols/typewriter/#api-token-configuration" }, "Segment API token"),
                        ", using cache instead")),
                });
            }
            else {
                try {
                    const trackingPlan = yield __await(api_1.fetchTrackingPlan({
                        id: trackingPlanConfig.id,
                        workspaceSlug: trackingPlanConfig.workspaceSlug,
                        token,
                    }));
                    yield __await(api_1.writeTrackingPlan(configPath, trackingPlan, trackingPlanConfig));
                }
                catch (err) {
                    // TODO: more reliable network connection detection
                    step.notes.push({
                        type: 'warning',
                        text: 'API request failed, using cache',
                    });
                    yield yield __await(state);
                }
            }
        }
        else {
            step.notes.push({
                text: `Loading from ${trackingPlanConfig.path + '/' + api_1.TRACKING_PLAN_FILENAME}`,
            });
            yield yield __await(state);
        }
        const loadedTrackingPlan = yield __await(api_1.loadTrackingPlan(configPath, trackingPlanConfig));
        step.notes.push({
            key: 'which-tracking-plan',
            text: (react_1.default.createElement(ink_1.Text, null,
                "Using ",
                '',
                react_1.default.createElement(ink_link_1.default, { url: `https://app.segment.com/${trackingPlanConfig.workspaceSlug}/protocols/tracking-plans/${trackingPlanConfig.id}` }, loadedTrackingPlan.display_name))),
        });
        yield yield __await(state);
        if (genOptions.update) {
            const deltas = api_1.computeDelta(previousSegmentTrackingPlan, loadedTrackingPlan);
            step.notes.push({
                key: 'changes',
                text: deltas.added === 0 && deltas.modified === 0 && deltas.removed === 0 ? ('No changes found') : (react_1.default.createElement(ink_1.Text, null,
                    react_1.default.createElement(ink_1.Color, { grey: deltas.added === 0, green: deltas.added > 0 },
                        deltas.added,
                        " added"),
                    ",",
                    ' ',
                    react_1.default.createElement(ink_1.Color, { grey: deltas.modified === 0, yellow: deltas.modified > 0 },
                        deltas.modified,
                        " modified"),
                    ",",
                    ' ',
                    react_1.default.createElement(ink_1.Color, { grey: deltas.removed === 0, red: deltas.removed > 0 },
                        deltas.removed,
                        " removed"))),
            });
            yield yield __await(state);
        }
        const trackingPlan = {
            trackCalls: loadedTrackingPlan.rules.events
                // Typewriter doesn't yet support event versioning. For now, we just choose the most recent version.
                .filter(e => loadedTrackingPlan.rules.events.every(e2 => e.name !== e2.name || e.version >= e2.version))
                .map(e => (Object.assign({}, e.rules, { title: e.name, description: e.description }))),
        };
        step.running = false;
        step.done = true;
        yield yield __await(state
        // Step 2. Remove any previously generated files from the configured path.
        // We identify which files to clear using the `SEGMENT_AUTOGENERATED_FILE_WARNING` at the
        // top of every file.
        );
        // Step 2. Remove any previously generated files from the configured path.
        // We identify which files to clear using the `SEGMENT_AUTOGENERATED_FILE_WARNING` at the
        // top of every file.
        step = state.steps.clearFiles;
        step.running = true;
        yield yield __await(state);
        const path = config_1.resolveRelativePath(configPath, trackingPlanConfig.path);
        yield __await(config_1.verifyDirectoryExists(path));
        yield __await(clearFolder(path));
        step.running = false;
        step.done = true;
        yield yield __await(state
        // Step 3: Generate the client and write it to the user's file system.
        );
        // Step 3: Generate the client and write it to the user's file system.
        step = state.steps.generateClient;
        step.running = true;
        step.notes.push({
            text: `Building for ${genOptions.production ? 'production' : 'development'}`,
        });
        step.notes.push({
            text: `Writing to ${trackingPlanConfig.path}`,
        });
        yield yield __await(state);
        const files = yield __await(gen_1.gen(trackingPlan, {
            client: config.client,
            typewriterVersion: package_json_1.version,
            isDevelopment: !genOptions.production,
        }));
        for (var file of files) {
            const path = config_1.resolveRelativePath(configPath, trackingPlanConfig.path, file.path);
            yield __await(config_1.verifyDirectoryExists(path, 'file'));
            yield __await(writeFile(path, file.contents, {
                encoding: 'utf-8',
            }));
        }
        step.running = false;
        step.done = true;
        yield yield __await(state
        // Step 4: Optionally run the user's scripts.after script, if one was supplied.
        );
        // Step 4: Optionally run the user's scripts.after script, if one was supplied.
        step = state.steps.afterScript;
        if (!step.skipping) {
            step.running = true;
            yield yield __await(state);
            if (config.scripts && config.scripts.after) {
                step.notes.push({
                    text: config.scripts.after,
                });
                yield yield __await(state);
                yield __await(exec(config.scripts.after).catch(err => {
                    step.notes.push({
                        type: 'warning',
                        text: String(err),
                    });
                }));
            }
            step.running = false;
            step.done = true;
            yield yield __await(state);
        }
    });
}
// clearFolder removes all typewriter-generated files from the specified folder
// excluding plan.json.
// It uses a simple heuristic to avoid accidentally clobbering a user's files --
// it only clears files with the "this file was autogenerated by Typewriter" warning.
// Therefore, all generators need to output that warning in a comment in the first few
// lines of every generated file.
function clearFolder(path) {
    return __awaiter(this, void 0, void 0, function* () {
        const fileNames = yield readdir(path, 'utf-8');
        for (let fileName of fileNames) {
            const fullPath = path_1.join(path, fileName);
            try {
                const contents = yield readFile(fullPath, 'utf-8');
                if (contents.includes(templates_1.SEGMENT_AUTOGENERATED_FILE_WARNING)) {
                    yield unlink(fullPath);
                }
            }
            catch (err) {
                // Note: none of our generators produce folders, but if we ever do, then we'll need to
                // update this logic to handle recursively traversing directores.
                // In the mean time, protect against
                if (err.code !== 'EISDIR') {
                    yield clearFolder(fullPath);
                }
            }
        }
    });
}
//# sourceMappingURL=build.js.map