#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const ink_1 = require("ink");
const commands_1 = require("./commands");
const reportAnalytics_1 = require("./reportAnalytics");
function toYargsHandler(Command, props, cliOptions) {
    // Return a closure which yargs will execute if this command is run.
    return (args) => __awaiter(this, void 0, void 0, function* () {
        // The '*' command is a catch-all. We want to fail the CLI if an unknown command is
        // supplied ('yarn typewriter footothebar'), instead of just running the default command.
        if (cliOptions &&
            cliOptions.validateDefault &&
            args._.length !== 0 &&
            !['update', 'u'].includes(args._[0])) {
            // TODO: better error reporting here.
            throw new Error(`Unknown command: '${args._[0]}'`);
        }
        const logError = (log) => (args.debug ? console.trace(log) : null);
        const f = (config) => __awaiter(this, void 0, void 0, function* () {
            let Component = Command;
            // Certain flags (--version, --help) will overide whatever command was provided.
            if (!!args.version || !!args.v || Command.displayName === commands_1.Version.displayName) {
                // We override the --version flag from yargs with our own output. If it was supplied, print
                // the `version` component instead.
                Component = commands_1.Version;
            }
            else if (!!args.help ||
                !!args.h ||
                args._.includes('help') ||
                Command.displayName === commands_1.Help.displayName) {
                // Same goes for the --help flag.
                Component = commands_1.Help;
            }
            const { waitUntilExit } = ink_1.render(react_1.default.createElement(commands_1.ErrorBoundary, { logError: logError },
                react_1.default.createElement(Component, Object.assign({ configPath: args.config, config: config, logError: logError }, props))), { debug: !!args.debug });
            yield waitUntilExit();
        });
        try {
            // reportAnalytics will execute f() and report analytics to Segment.
            yield reportAnalytics_1.reportAnalytics(args, f);
        }
        catch (err) {
            const { waitUntilExit } = ink_1.render(react_1.default.createElement(commands_1.ErrorComponent, { error: err, logError: logError }), {
                debug: !!args.debug,
            });
            yield waitUntilExit();
        }
    });
}
const commandDefaults = {
    builder: {
        config: {
            type: 'string',
            default: './',
        },
        version: {
            type: 'boolean',
            default: false,
        },
        v: {
            type: 'boolean',
            default: false,
        },
        help: {
            type: 'boolean',
            default: false,
        },
        h: {
            type: 'boolean',
            default: false,
        },
        debug: {
            type: 'boolean',
            default: false,
        },
    },
};
require('yargs')
    .command(Object.assign({}, commandDefaults, { command: ['init', 'initialize', 'quickstart'], handler: toYargsHandler(commands_1.Init, {}) }))
    .command(Object.assign({}, commandDefaults, { command: ['update', 'u', '*'], handler: toYargsHandler(commands_1.Build, { production: false, update: true }, { validateDefault: true }) }))
    .command(Object.assign({}, commandDefaults, { command: ['build', 'b', 'd', 'dev', 'development'], handler: toYargsHandler(commands_1.Build, { production: false, update: false }) }))
    .command(Object.assign({}, commandDefaults, { command: ['prod', 'p', 'production'], handler: toYargsHandler(commands_1.Build, { production: true, update: false }) }))
    .command(Object.assign({}, commandDefaults, { command: ['token', 'tokens', 't'], handler: toYargsHandler(commands_1.Token, {}) }))
    .command(Object.assign({}, commandDefaults, { command: 'version', handler: toYargsHandler(commands_1.Version, {}) }))
    .command(Object.assign({}, commandDefaults, { command: 'help', handler: toYargsHandler(commands_1.Help, {}) }))
    .strict(true)
    // We override help + version ourselves.
    .help(false)
    .showHelpOnFail(false)
    .version(false).argv;
//# sourceMappingURL=index.js.map